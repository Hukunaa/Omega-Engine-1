#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "random.glsl"
#include "payload.glsl"

#define MAX_BOUNCES 4

layout(set = 0, binding = 0) uniform accelerationStructureNV Scene;
layout(set = 0, binding = 1, rgba8) uniform image2D ResultImage;
layout(set = 0, binding = 2) uniform UniformData 
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 data;
} ubo;

layout(set = 0, binding = 8, rgba32f) uniform image2D AccumulationImage;

layout(location = 0) rayPayloadNV Payload tracedData;

uint seedRand = 0;

void main() {
    //const vec2 uv = vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy - 1);
    /*vec4 uv = vec4(gl_LaunchIDNV.xy, -1, 1) * ubo.viewInverse * ubo.projInverse;
    const vec3 origin = vec3(uv.x, uv.y, uv.z);
    const vec3 direction = vec3(0.0f, 0.0f, 1.0f);*/
    //seedRand = ubo.cameraSeed;

    uint pixelRandomSeed = uint(ubo.data.w);
    tracedData.seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDNV.x, gl_LaunchIDNV.y), pixelRandomSeed);

    const vec2 pixel = vec2(gl_LaunchIDNV.x + RandomFloat(pixelRandomSeed), gl_LaunchIDNV.y + RandomFloat(pixelRandomSeed));
    const vec2 uv = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;

    vec2 offset = ubo.data.y / 2 * RandomInUnitDisk(tracedData.seed);
	vec4 origin = ubo.viewInverse * vec4(offset,0,1);
	vec4 target = ubo.projInverse * vec4(uv.x, uv.y, 1, 1);
	vec4 direction = ubo.viewInverse*vec4(normalize(target.xyz * ubo.data.x - vec3(offset, 0)), 0);

    tracedData.newOrigin = vec3(origin.xyz);
    tracedData.newDir = vec3(direction.xyz);
    tracedData.cameraPos = tracedData.newOrigin;
    tracedData.reflectanceFactor = 1;

    const uint rayFlags = gl_RayFlagsNoneNV;
    const uint cullMask = 0xFF;
    const uint sbtRecordOffset = 0;
    const uint sbtRecordStride = 0;
    const uint missIndex = 0;
    const float tmin = 0.0f;
    const float tmax = 10000.0f;
    const int payloadLocation = 0;

    vec3 color = vec3(1);
    for(int i = 0; i < MAX_BOUNCES; ++i)
    {
        float refFactor = tracedData.reflectanceFactor;
        traceNV(Scene,
                rayFlags,
                cullMask,
                sbtRecordOffset,
                sbtRecordStride,
                missIndex,
                tracedData.newOrigin,
                tmin,
                tracedData.newDir,
                tmax,
                payloadLocation);

        color += tracedData.color * refFactor;
        if(!tracedData.hasHit)
            break;
    }
    color /= MAX_BOUNCES;

    vec3 previousColor = imageLoad(AccumulationImage, ivec2(gl_LaunchIDNV.xy)).rgb;
    vec3 finalColor = mix(previousColor, color, 1 / (ubo.data.z + 1));

    imageStore(AccumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(finalColor, 1.0f));
    imageStore(ResultImage, ivec2(gl_LaunchIDNV.xy), vec4(finalColor, 1.0f));
}