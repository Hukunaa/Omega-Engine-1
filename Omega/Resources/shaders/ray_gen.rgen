#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "random.glsl"
#include "payload.glsl"

#define RECURSION_DEPTH 1
#define MAX_BOUNCES 1
#define GI_RESOLUTION 2

#define PI 3.141592653589793

layout(set = 0, binding = 0) uniform accelerationStructureNV Scene;
layout(set = 0, binding = 1, rgba8) uniform image2D ResultImage;
layout(set = 0, binding = 2) uniform UniformData 
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 data;
    vec4 DOFenabled;
    vec4 samples;
} ubo;

layout(set = 0, binding = 8, rgba32f) uniform image2D AccumulationImage;

layout(location = 0) rayPayloadNV Payload tracedData;

uint seedRand = 0;

void main() {
    //const vec2 uv = vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy - 1);
    /*vec4 uv = vec4(gl_LaunchIDNV.xy, -1, 1) * ubo.viewInverse * ubo.projInverse;
    const vec3 origin = vec3(uv.x, uv.y, uv.z);
    const vec3 direction = vec3(0.0f, 0.0f, 1.0f);*/
    //seedRand = ubo.cameraSeed;

    uint pixelRandomSeed = uint(ubo.data.w);
    tracedData.seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDNV.x, gl_LaunchIDNV.y), pixelRandomSeed);


    //uint cameraRays = ubo.samples.x;
    float aperture = ubo.data.y;

    if(ubo.DOFenabled.x == 0)
    {
        //cameraRays = 1;
        aperture = 0;
    }

    vec3 final = vec3(0);
    for(int s = 0; s < ubo.samples.x; ++s)
    {
        const vec2 pixel = vec2(gl_LaunchIDNV.x + RandomFloat(pixelRandomSeed), gl_LaunchIDNV.y + RandomFloat(pixelRandomSeed));
        const vec2 uv = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;

        vec2 offset = aperture / 2 * RandomInUnitDisk(tracedData.seed);
        vec4 origin = ubo.viewInverse * vec4(offset,0,1);
        vec4 target = ubo.projInverse * vec4(uv.x, uv.y, 1, 1);
        vec4 direction = ubo.viewInverse*vec4(normalize(target.xyz * ubo.data.x - vec3(offset, 0)), 0);

        tracedData.newOrigin = vec3(origin.xyz);
        tracedData.newDir = vec3(direction.xyz);
        tracedData.cameraPos = tracedData.newOrigin;

        const uint rayFlags = gl_RayFlagsNoneNV;
        const uint cullMask = 0xFF;
        const uint sbtRecordOffset = 0;
        const uint sbtRecordStride = 0;
        const uint missIndex = 0;
        const float tmin = 0.0f;
        const float tmax = 10000.0f;
        const int payloadLocation = 0;

        vec3 directLighting = vec3(0);
        vec3 indirectLighting = vec3(0);
        vec3 baseAlbedo = vec3(0);
        vec3 normal = vec3(0);
        Payload hitRecord;
        for(int i = 0; i < RECURSION_DEPTH; ++i)
        {
            traceNV(Scene,
                    rayFlags,
                    cullMask,
                    sbtRecordOffset,
                    sbtRecordStride,
                    missIndex,
                    tracedData.newOrigin,
                    tmin,
                    tracedData.newDir,
                    tmax,
                    payloadLocation);
            hitRecord = tracedData;

            baseAlbedo = hitRecord.baseAlbedo;
            normal = hitRecord.normal;

            directLighting += hitRecord.color;
            if(!hitRecord.hasHit)
                break;

            vec3 origin = hitRecord.newOrigin;
            vec3 indirectDir = normal + RandomInUnitSphere(hitRecord.seed);
            for(int j = 0; j < GI_RESOLUTION; ++j)
            {
                traceNV(Scene,
                    rayFlags,
                    cullMask,
                    sbtRecordOffset,
                    sbtRecordStride,
                    missIndex,
                    origin,
                    tmin,
                    indirectDir,
                    tmax,
                    payloadLocation);
                Payload hitIndirect = tracedData;

                indirectLighting += hitIndirect.color * baseAlbedo * dot(normal, indirectDir);
                indirectDir = normal + RandomInUnitSphere(hitRecord.seed);
            }
            indirectLighting /= GI_RESOLUTION;
        }

        final += (directLighting / PI + 2 * indirectLighting) * baseAlbedo / PI;
    }

    final /= ubo.samples.x;
    //final = sqrt(final);

    vec3 oldColor;
    if(ubo.samples.y != 0)
        oldColor = imageLoad(AccumulationImage, ivec2(gl_LaunchIDNV.xy)).rgb;
    else
        oldColor = final;

    vec3 newColor = mix(oldColor, final, 1 / (ubo.samples.y + 1));

    imageStore(AccumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(newColor, 1.0f));
    imageStore(ResultImage, ivec2(gl_LaunchIDNV.xy), vec4(newColor, 1.0f));
}


    //vec3 finalColor = mix(previousColor, final, 1 / (ubo.data.z + 1));

    //imageStore(AccumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(previousColor, 1.0f));